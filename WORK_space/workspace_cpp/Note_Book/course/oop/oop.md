**unordered_set**
* unordered_set 容器和 set 容器很像，唯一的区别就在于 set 容器会自行对存储的数据进行排序，而 unordered_set 容器不会。  
###### 特点：
>1.不再以键值对的形式存储数据，而是直接存储数据的值；  
2.容器内部存储的各个元素的值都互不相等，且不能被修改。  
3.不会对内部存储的数据进行排序（这和该容器底层采用哈希表结构存储数据有关；
### 第一次课：   
regex 正则表达式；

文件读写 ：

```c++
#include<iostream>
#include<fstream>
#include<string>
#include<regex>
using namespace std;

int main()
{
    string s = "Hello , Student@zju";
    regex re("a|e|i|o|u");
    string s1=regex_replace(s, re ,"*");
    cout<< s << endl<<s1;
}
```
### 数字转字符串 to_string()
```c++
#include<iostream>
using namespace std;
int main()
{
	int n = 541;
	cout << "整数变字符串：" + to_string(n) << endl;
	
	double d = 62.122;
	cout << "浮点数变字符串：" + to_string(d) << endl;
}

```
#### vector初始化：
* v.resize(int n,element)表示调整容器vv的大小为n，扩容后的每个元素的值为element，默认为0
* resize()会改变容器的容量和当前元素个数

## STL
* deque(double-end queue)  
* [begin , end)

## 奇奇怪怪的小知识：
> C++ 参数加入const &的作用: 
 * 一.作为传入参数不可以修改其值  
 * 二.如果实参与形参的数据类型相同时，则不会创建新的临时变量
 ，即形参和实参的地址相同  
 * 三.如果实参与形参的数据类型不同时，则会在函数体中创建一个
 新的形参临时变量来存储实参类型，这里会自动对实参进行强制类型
 转化，转化为形参类型，此时形参与实参地址不同  

## 类  
>构造函数： 
>  * 构造函数的名称与类的名称是完全相同的，并且不会返回任何
类型，也不会返回 void。构造函数可用于为某些成员变量设置初始值。   
```c++
     //使用初始化列表来初始化字段 
    Line::Line( double len): length(len)
    {
        cout << "Object is being created, length = " << len << endl;
    }
    等价于：  
    Line::Line( double len)
    {
        length = len;
        cout << "Object is being created, length = " << len << endl;
    } 
```
>const &是C++中用于声明常量引用的语法。它可以在函数参数
、函数返回类型和变量声明中使用。  
> 1.函数参数：通过将参数声明为const &，可以传递常量对象
或临时对象给函数，并防止函数修改传入的对象。这样做既可以提
高效率（避免不必要的拷贝），还能保护传入的对象的数据完整性.  
    2.函数返回类型：函数可以返回一个常量引用，使得函数的返
    回值成为一个不可修改的对象，并且避免了额外的拷贝操作  
    3.变量声明：在变量声明时，可以使用const &来创建常量引
    用，用于引用其他对象。这样做可以避免不必要的拷贝，并保
    证被引用对象的数据不会被修改。  


### 例子：
```C++
#include<iostream>
using namespace std;

class Obj {
    char c; // 字符型成员变量
public:
    Obj(char cc) { // 构造函数，接受一个字符参数
        c = cc;
        cout << "Obj::Obj(char cc) for " << c << endl;
    }
    
    ~Obj() { // 析构函数
        cout << "Obj::~Obj() for " << c << endl;
    }
};

void f() {
    static Obj b('b'); // 静态对象b，只会在第一次调用时初始化
}

void g() {
    Obj c('c'); // 每次调用g()都会创建一个新对象c
}

Obj a('a'); // 全局对象a

int main() {
    cout << "inside main()" << endl;
    f(); // 调用函数f()
    g(); // 调用函数g()
    f(); // 再次调用函数f()
    g(); // 再次调用函数g()
    cout << "leaving main()" << endl;
    
    return 0;
}
```
_程序的执行顺序如下：_  

>    首先，全局对象Obj a('a')被创建，输出Obj::Obj(char cc) for a。  
    进入main()函数，输出inside main()。  
    调用函数f()：    
    第一次调用时，静态对象Obj b('b')被创建，输出Obj::Obj(char cc) for b。  
    调用函数g()：  
    第一次调用时，局部对象Obj c('c')被创建，输出Obj::Obj(char cc) for c。  
    再次调用函数f()：  
    这次由于静态对象b已经存在，不会再次创建。  
    再次调用函数g()：  
    这次又会创建一个新的局部对象Obj c('c')，输出Obj::Obj(char cc) for c。  
    输出leaving main()。  
    程序结束，全局和静态对象的析构函数被调用：  
    静态对象b的析构函数输出Obj::~Obj() for b。  
    全局对象a的析构函数输出Obj::~Obj() for a。  
    总结来说，这段代码演示了全局对象、静态对象、构造函数和析
    构函数的调用顺序。  
    **全局对象在程序开始时创建，在程序结束时销毁；静态对象在第
    一次调用时创建，在程序结束时销毁；局部对象在每次函数调用时
    创建，在函数结束时销毁。构造函数在对象创建时调用，析构函数
    在对象销毁时调用**。  

> 当创建派生类的实例时，会同时创建基类和派生类的对象，并且基类部分的构造函数会被调用。

### 拷贝构造函数
>拷贝构造函数用于创建一个对象，该对象与已有对象具有相同的值。拷贝构造函数的参数是一个同类对象的引用。当使用以下情况时，会调用拷贝构造函数：
>>* 用一个对象初始化另一个对象时。
>>* 将一个对象作为函数的参数传递给函数。
>>* 在函数中返回一个对象

### static
>在C++中，类的静态成员（static member）必须在类内声明，在类外初始化
>>因为静态成员属于整个类，而不属于某个对象，如果在类内初始化，会导致每个对象都包含该静态成员，这是矛盾的。
``` c++
class A
    {  
    private:
        static int count ; // 类内声明
    };

    int A::count = 0 ; // 类外初始化，不必再加static关键字
```
>* 静态成员函数主要为了调用方便，不需要生成对象就能调用。
```c++
class X
{
public:
    void MethodA();
    static void MethodB();
}
```
> - 此时MethodB可以直接调用，X::MethodB();  
>- MethodA必须先生成类对象才能调用，X x; x.MethodA();
>- 函数的行为对所有派生类都一致时，可以声明为静态。  
>- 静态成员函数的作用基本上相当于：一个带有命名空间的全局函数。  
> - 如一个数学类定义了一些函数 都可以声明伪静态的 Math.sin(x)等  

##### 内存角度分析：
>类的静态成员(数据成员和函数成员)为类本身所有，在类加载的时候就会分配内存，可以通过类名直接访问；非静态成员(数据成员和函数成员)属于类的实例所有，所以只有在创建类的实例的时候才会分配内存，并通过实例去访问。
>>注意：类的静态数据成员是静态存储，它是静态生存周期，必须进行初始化。  
>>注意：静态数据成员的初始化在类体外进行，前面不加static以免与一般静态变量或者对象混淆。



##### 静态成员函数访问非静态成员报错：

>类的静态成员在类加载的时候就已经分配内存，而此时类的非静态成员尚未分配内存，访问内存中不存在的东西自然会出错。

### example
```c++
#include<iostream>
 
using namespace std;
 
class Test
{
public:
    Test(){}
    Test(int _m):_cm(_m){}
    int get_cm()const
    {
       return _cm;
    }
 
private:
    int _cm;
};
 
 
 
void Cmf(const Test& _tt)
{
    cout<<_tt.get_cm();
}
 
int main(void)
{
    Test t(8);
    Cmf(t);
    system("pause");
    return 0;
}
```
> **one**:  
>在成员函数声明中，const关键字表示该成员函数是一个常量成员函数。常量成员函数表示该函数不会修改对象的任何成员变量。在这个例子中，get_cm()函数被声明为常量成员函数，因此编译器会在函数体内保证不会修改对象的成员变量。  
> 在函数定义中，如果成员函数没有修改对象的任何成员变量，应该将其声明为常量成员函数。这样做可以提供一些重要的优势：
>> * 明确表明该函数不会改变对象的状态，提高代码可读性。
>> * 允许在常量对象上调用该函数，因为常量对象不能调用非常量成员函数。  
>> **在本例中，get_cm()函数不会修改对象的成员变量，因此应该声明为常量成员函数，以便在常量对象上调用该函数**。

> **two:**
>在函数Cmf()的参数中，使用了常量引用(const &)的方式来接收Test类的对象_tt。这样做有以下几个原因：  
>1. 避免不必要的拷贝：使用常量引用作为函数参数，可以避免在函数调用过程中对对象进行拷贝构造。如果不使用常量引用，而是直接传递对象，那么在函数调用时会触发拷贝构造函数，导致额外的开销和性能损失。  
>2.支持常量对象：使用常量引用作为参数，可以接受常量对象作为实参。如果不使用常量引用，而是使用非常量引用，那么只能接受非常量对象作为实参，而无法接受常量对象。  
>3.避免修改对象：使用常量引用作为参数，可以确保在函数内部不会修改传递的对象。常量引用表示函数不会修改对象的状态，增加了代码的可读性和安全性。
>>因此，在这个例子中，使用const Test&作为参数类型，表示函数Cmf()接受一个常量引用，用于接收Test类的对象_tt，并在函数内部使用该对象的成员函数进行操作，同时避免了不必要的拷贝和修改对象的风险。

*注意：const 关键字不能与 static 关键字同时使用，因为 static 关键字修饰静态成员函数，静态成员函数不含有 this 指针，即不能实例化，const 成员函数必须具体到某一实例。*  
>**如果有个成员函数想修改对象中的某一个成员怎么办？这时我们可以使用 mutable 关键字修饰这个成员，mutable 的意思也是易变的，容易改变的意思，被 mutable 关键字修饰的成员可以处于不断变化中，如下面的例子**

```c++
#include<iostream>
using namespace std;
class Test
{
public:
    Test(int _m,int _t):_cm(_m),_ct(_t){}
    void Kf()const
    {
        ++_cm; // 错误
        ++_ct; // 正确
    }
private:
    int _cm;
    mutable int _ct;
};
 
int main(void)
{
    Test t(8,7);
    return 0;
}
```

*Upcast是将派生类对象的指针或引用转换为基类指针或引用的过程。它用于实现多态性，通过基类指针或引用调用派生类对象的成员函数。*

*Downcast是将基类指针或引用转换为派生类指针或引用的过程。它需要显式转换，并且可能需要使用dynamic_cast进行类型检查，以确保转换的安全性。Downcast用于访问派生类特有的成员和方法。*

>需要注意的是，在成员函数内部，可以省略this指针的使用。编译器会自动将成员变量和成员函数解析为当前对象的成员。但是，在某些情况下，使用this指针可以增加代码的可读性和明确性。
>>总结：在C++中，this是一个指向当前对象的指针，用于在类的成员函数中访问对象的成员变量和成员函数。它可以避免与其他对象的成员混淆，并提供对当前对象的明确引用。

#### 虚函数
>纯虚函数：
```C++
class <类名>
{
virtual <类型><函数名>(<参数表>)=0;
…
};
```
>引入原因：
* 为了方便使用多态特性，我们常常需要在基类中定义虚拟函数

* 在很多情况下，基类本身生成对象是不合情理的。例如，动物作为一个基类可以派生出老虎、孔雀等子类，但动物本身生成对象明显不合常理

So,编译器要求在派生类中必须予以重写以实现多态性。同时**含有纯虚拟函数的类称为抽象类**，它不能生成对象,但是可以定义指针。

## 派生类

* 在创建对象时，先调用基类的构造函数，再调用派生类的构造函数；  
* 在删除对象时，先调用基类的析构函数，再调用成员对象的析构函数。