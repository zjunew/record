C51 COMPILER V9.59.0.0   THIRD                                                             05/30/2024 09:04:38 PAGE 1   


C51 COMPILER V9.59.0.0, COMPILATION OF MODULE THIRD
OBJECT MODULE PLACED IN .\Objects\third.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE ..\forth_pro\third.c OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND PRINT(.
                    -\Listings\third.lst) TABS(2) OBJECT(.\Objects\third.obj)

line level    source

   1          #include <reg51.h>
   2          #include <stdlib.h>
   3          #include <string.h>
   4          //---重定义关键词---//
   5          
   6          #define LCD1602_DATAPINS P0
   7          sbit LCD1602_E=P2^7;
   8          sbit LCD1602_RW=P2^5;
   9          sbit LCD1602_RS=P2^6;
  10          
  11          void Lcd1602_Delay1ms(unsigned int c);   //误差 0us
  12          
  13          void LcdWriteCom(unsigned char com);
  14            
  15          void LcdWriteData(unsigned char dat);
  16          void LcdInit(); 
  17          #define GPIO_KEY P1
  18          
  19          unsigned char KeyValue;
  20          unsigned char KeyState;
  21          
  22          unsigned char oper_state;
  23          unsigned char MY_oper;
  24          
  25          unsigned char dat[]="0123456789ABCDEF+-*/()=";
  26          unsigned char nums[20];
  27          unsigned char re[8];
  28          int count = 0;
  29          
  30          sbit key1=P3^0;
  31          sbit key2=P3^1;
  32          sbit key3=P3^2;
  33          sbit key4=P3^3;
  34          sbit key5=P3^4;
  35          sbit key6=P3^5;
  36          sbit key7=P3^6;
  37          sbit key8=P3^7;
  38          
  39          void Delay10ms();  
  40          void KeyDown();   
  41          void delay(unsigned char i)
  42          {
  43   1        while(i--); 
  44   1      }
  45          
  46          void operater_down()
  47          {
  48   1        if(key1 == 0)     
  49   1        { 
  50   2          delay(1000);   
  51   2          if(key1 == 0) 
  52   2          {
  53   3            oper_state = 1;
  54   3            MY_oper = 16 ;
C51 COMPILER V9.59.0.0   THIRD                                                             05/30/2024 09:04:38 PAGE 2   

  55   3          }
  56   2          while( !key1 );  
  57   2        } 
  58   1        if(key2 == 0)     
  59   1        { 
  60   2          delay(1000);
  61   2          if(key2 == 0) 
  62   2          {
  63   3            oper_state = 1;
  64   3            MY_oper = 17 ;
  65   3          }
  66   2          while(!key2);  
  67   2        } 
  68   1        if(key3 == 0)     
  69   1        { 
  70   2          delay(1000);
  71   2          if(key3 == 0) 
  72   2          {
  73   3            oper_state = 1;
  74   3            MY_oper = 18 ;
  75   3          }
  76   2          while(!key3);  
  77   2        } 
  78   1        if(key4 == 0)     
  79   1        { 
  80   2          delay(1000);
  81   2          if(key4 == 0) 
  82   2          {
  83   3            oper_state = 1;
  84   3            MY_oper = 19 ;
  85   3          }
  86   2          while(!key4);  
  87   2        } 
  88   1        if(key5 == 0)     
  89   1        { 
  90   2          delay(1000); 
  91   2          if(key5 == 0) 
  92   2          {
  93   3            oper_state = 1;
  94   3            MY_oper = 20 ;
  95   3          }
  96   2          while(!key5);  
  97   2        } 
  98   1        // if(key6 == 0)      
  99   1        // {  
 100   1        //  delay(2000);
 101   1        //  if(key6 == 0) 
 102   1        //  {
 103   1        //    oper_state = 1;
 104   1        //    MY_oper = 21 ;
 105   1        //  }
 106   1        //  while(!key6);  
 107   1        // }  
 108   1        if(key7 == 0)     
 109   1        { 
 110   2          delay(1000);
 111   2          if(key7 == 0) 
 112   2          {
 113   3            oper_state = 1;
 114   3            MY_oper = 21 ;
 115   3          }
 116   2          while(!key7);  
C51 COMPILER V9.59.0.0   THIRD                                                             05/30/2024 09:04:38 PAGE 3   

 117   2        } 
 118   1        if(key8 == 0)     
 119   1        { 
 120   2          delay(1000);  
 121   2          if(key8 == 0) 
 122   2          {
 123   3            oper_state = 1;
 124   3            MY_oper = 22 ;
 125   3          }
 126   2          while(!key8);  
 127   2        } 
 128   1      }
 129          
 130          void main(void)
 131          {
 132   1        unsigned char i;
 133   1        LcdInit();
 134   1        KeyState=0;
 135   1        oper_state = 0;
 136   1        while(1)
 137   1        {
 138   2          KeyDown();
 139   2          if(KeyState)
 140   2          {
 141   3            KeyState=0;
 142   3            LcdWriteCom(0x80);
 143   3                  nums[count] = KeyValue;
 144   3            count++;
 145   3            for(i = 0 ; i < count ; i++)
 146   3                      LcdWriteData(dat[nums[i]]);
 147   3          }
 148   2      
 149   2          operater_down();
 150   2      
 151   2          if(oper_state)
 152   2          {
 153   3                  nums[count] = MY_oper ;
 154   3                  LcdWriteCom(0x80);
 155   3                  count++;
 156   3                  for(i = 0 ; i < count ; i++)
 157   3                      LcdWriteData(dat[nums[i]]);
 158   3                  oper_state = 0 ;
 159   3          }
 160   2        }       
 161   1      }
 162          
 163          void KeyDown(void)
 164          {
 165   1        char a;
 166   1        GPIO_KEY=0x0f;
 167   1        if(GPIO_KEY!=0x0f)
 168   1        {
 169   2          Delay10ms();
 170   2          if(GPIO_KEY!=0x0f)
 171   2          {
 172   3            KeyState=1;
 173   3            //测试列
 174   3            GPIO_KEY=0X0F;
 175   3      //      Delay10ms();
 176   3            switch(GPIO_KEY)
 177   3            {
 178   4              case(0X07): KeyValue=0;break;
C51 COMPILER V9.59.0.0   THIRD                                                             05/30/2024 09:04:38 PAGE 4   

 179   4              case(0X0b): KeyValue=1;break;
 180   4              case(0X0d): KeyValue=2;break;
 181   4              case(0X0e): KeyValue=3;break;
 182   4      //        default:  KeyValue=17;  //检测出错回复17意思是把数码管全灭掉。
 183   4            }
 184   3            //测试行
 185   3            GPIO_KEY=0XF0;
 186   3            Delay10ms();
 187   3            switch(GPIO_KEY)
 188   3            {
 189   4              case(0X70): KeyValue=KeyValue;break;
 190   4              case(0Xb0): KeyValue=KeyValue+4;break;
 191   4              case(0Xd0): KeyValue=KeyValue+8;break;
 192   4              case(0Xe0): KeyValue=KeyValue+12;break;
 193   4      //        default:  KeyValue=17;
 194   4            }
 195   3            while((a<50)&&(GPIO_KEY!=0xf0))  //检测按键松手检测
 196   3            {
 197   4              Delay10ms();
 198   4              a++;
 199   4            }
 200   3            a=0;
 201   3          }
 202   2        }
 203   1      }
 204          
 205          void Delay10ms(void)   //误差 0us
 206          {
 207   1          unsigned char a,b,c;
 208   1          for(c=1;c>0;c--)
 209   1              for(b=38;b>0;b--)
 210   1                  for(a=130;a>0;a--);
 211   1      }
 212          
 213          void LcdWriteCom(unsigned char com)   //写入命令
 214          {
 215   1        LCD1602_E = 0;   //使能清零
 216   1        LCD1602_RS = 0;  //选择写入命令
 217   1        LCD1602_RW = 0;  //选择写入
 218   1      
 219   1        LCD1602_DATAPINS = com; //由于4位的接线是接到P0口的高四位，所以传送高四位不用改
 220   1        Lcd1602_Delay1ms(1);
 221   1      
 222   1        LCD1602_E = 1;   //写入时序
 223   1        Lcd1602_Delay1ms(5);
 224   1        LCD1602_E = 0;
 225   1      
 226   1      //  Lcd1602_Delay1ms(1);
 227   1        LCD1602_DATAPINS = com << 4; //发送低四位
 228   1        Lcd1602_Delay1ms(1);
 229   1      
 230   1        LCD1602_E = 1;   //写入时序
 231   1        Lcd1602_Delay1ms(5);
 232   1        LCD1602_E = 0;
 233   1      }
 234          void Lcd1602_Delay1ms(unsigned int c)   //误差 0us
 235          {
 236   1          unsigned char a,b;
 237   1        for (; c>0; c--)
 238   1        {
 239   2           for (b=199;b>0;b--)
 240   2           {
C51 COMPILER V9.59.0.0   THIRD                                                             05/30/2024 09:04:38 PAGE 5   

 241   3              for(a=1;a>0;a--);
 242   3           }      
 243   2        }
 244   1            
 245   1      }
 246          
 247          void LcdWriteData(unsigned char dat)      //写入数据
 248          {
 249   1        LCD1602_E = 0;    //使能清零
 250   1        LCD1602_RS = 1;   //选择写入数据
 251   1        LCD1602_RW = 0;   //选择写入
 252   1      
 253   1        LCD1602_DATAPINS = dat; //由于4位的接线是接到P0口的高四位，所以传送高四位不用改
 254   1        Lcd1602_Delay1ms(1);
 255   1      
 256   1        LCD1602_E = 1;    //写入时序
 257   1        Lcd1602_Delay1ms(5);
 258   1        LCD1602_E = 0;
 259   1      
 260   1        LCD1602_DATAPINS = dat << 4; //写入低四位
 261   1        Lcd1602_Delay1ms(1);
 262   1      
 263   1        LCD1602_E = 1;    //写入时序
 264   1        Lcd1602_Delay1ms(5);
 265   1        LCD1602_E = 0;
 266   1      }
 267          void LcdInit()              //LCD初始化子程序
 268          {
 269   1        LcdWriteCom(0x32);   //将8位总线转为4位总线
 270   1        LcdWriteCom(0x28);   //在四位线下的初始化
 271   1        LcdWriteCom(0x0c);  //开显示不显示光标
 272   1        LcdWriteCom(0x06);  //写一个指针加1
 273   1        LcdWriteCom(0x01);  //清屏
 274   1        LcdWriteCom(0x80);  //设置数据指针起点
 275   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    626    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     58       3
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
