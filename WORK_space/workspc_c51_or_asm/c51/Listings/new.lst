C51 COMPILER V9.59.0.0   NEW                                                               05/25/2024 19:24:56 PAGE 1   


C51 COMPILER V9.59.0.0, COMPILATION OF MODULE NEW
OBJECT MODULE PLACED IN .\Objects\new.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE ..\forth_pro\new.c OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND PRINT(.\L
                    -istings\new.lst) TABS(2) OBJECT(.\Objects\new.obj)

line level    source

   1          #include <reg51.h>
   2          /********************************ç¡¬ä»¶æ¥å£å®šä¹‰*********************************/
   3          #define RS  GPIO_Pin_1 //P2^6; 
   4          #define RW  GPIO_Pin_2 //P2^5;
   5          #define EN  GPIO_Pin_0 //P2^7;
   6          
   7          /********************************å®å®šä¹‰*********************************/
   8          #define    LCD_RS(x)  x ? GPIO_SetBits(GPIOB, RS): GPIO_ResetBits(GPIOB, RS)
   9          #define    LCD_RW(x)  x ? GPIO_SetBits(GPIOB, RW): GPIO_ResetBits(GPIOB, RW)
  10          #define    LCD_EN(x)  x ? GPIO_SetBits(GPIOB, EN): GPIO_ResetBits(GPIOB, EN)
  11          
  12          /********************** å˜é‡å®šä¹‰ ---------------------------*/
  13          GPIO_InitTypeDef GPIO_InitStructure;     //GPIO
*** ERROR C129 IN LINE 13 OF ..\forth_pro\new.c: missing ';' before 'GPIO_InitStructure'
  14          ErrorStatus HSEStartUpStatus; 
  15          typedef unsigned char BYTE;
  16          typedef unsigned char BOOL; 
  17          
  18          BYTE dis1[] = {"H "};
  19          BYTE dis2[] = {" "};
  20          BYTE dis_buf=0;            //æ˜¾ç¤ºç¼“å­˜
  21          BYTE temp;
  22          BYTE key;                //é”®é¡ºåºç 
  23          BYTE fuhao=32;
  24          BYTE flag=0;
  25          BYTE flag_buf=0;
  26          BYTE flag_fuhao=0;
  27          BYTE flag_fuhao2=0;
  28          BYTE j,m,n;
  29          int i=0;
  30          int operand[15] = {0};                /*æ•°å­—æ•°ç»„ï¼Œåˆå§‹åŒ–*/
  31          int  top_num = -1;
  32          BYTE oper[15] = {0};                  /*æ“ä½œç¬¦æ•°ç»„ï¼Œåˆå§‹åŒ–*/
  33          int top_oper = -1;   
  34          BYTE* temp_p;              // æ•°ç»„æŒ‡é’ˆ
  35          BYTE* str = dis1;
  36          BYTE dest[15];
  37          int num = 0; 
  38          
  39          /***************å£°æ˜å‡½æ•° ---------------*/
  40          void RCC_Configuration(void);//RCCåˆå§‹åŒ–
  41          void NVIC_Configuration(void);  //NVICåˆå§‹åŒ–
  42          void NOP(void);   //å»¶æ—¶å‘¨æœŸ
  43          void Delay(vu32 nCount);   //å»¶æ—¶ç¨‹åº
  44          void delay0(BYTE x);      //å»¶æ—¶å­ç¨‹åº
  45          void keyscan(void);    // çŸ©é˜µé”®ç›˜æ‰«æå­ç¨‹åº
  46          void duli_keyscan(void);  //ç‹¬ç«‹æŒ‰é”®æ‰«æå­ç¨‹åº
  47          void keydown(void);     //åˆ¤æ–­é”®ç›˜é”®æ˜¯å¦æŒ‰ä¸‹
  48          void calculate(void);     //åˆ¤æ–­é”®ç›˜é”®æ˜¯å¦æŒ‰ä¸‹
  49          void result2char(void);   //è®¡ç®—è¡¨è¾¾å¼çš„å€¼
  50          void LCD(void); //LCDæ˜¾ç¤º
  51          int insert_operand(int *operand , int * top_num ,BYTE num);//æ•°æ®å‹å…¥æ•°æ®æ ˆ 
  52          int insert_oper (BYTE * oper , int *top_oper , char ch);//æ“ä½œç¬¦å‹å…¥ç¬¦å·æ ˆ
  53          int compare(BYTE *oper , int *top_oper , BYTE ch);//æ¯”è¾ƒæ“ä½œæœä¼˜å…ˆçº§
C51 COMPILER V9.59.0.0   NEW                                                               05/25/2024 19:24:56 PAGE 2   

  54          int deal_date(int *operand ,BYTE *oper ,int *top_num, int *top_oper);//è¿›è¡Œæ•°æ®è¿ç®—
  55          
  56          //RCCåˆå§‹åŒ–
  57          void RCC_Configuration(void)
  58          {   
  59           //å¤ä½RCCå¤–éƒ¨è®¾å¤‡å¯„å­˜å™¨åˆ°é»˜è®¤å€¼
  60            RCC_DeInit();
  61            //æ‰“å¼€å¤–éƒ¨é«˜é€Ÿæ™¶æŒ¯
  62            RCC_HSEConfig(RCC_HSE_ON);
  63             //ç­‰å¾…å¤–éƒ¨é«˜é€Ÿæ—¶é’Ÿå‡†å¤‡å¥½
  64            HSEStartUpStatus = RCC_WaitForHSEStartUp();
  65            if(HSEStartUpStatus == SUCCESS)   //å¤–éƒ¨é«˜é€Ÿæ—¶é’Ÿå·²ç»å‡†åˆ«å¥½
  66            {                   
  67              //å¼€å¯FLASHçš„é¢„å–åŠŸèƒ½
  68              FLASH_PrefetchBufferCmd(FLASH_PrefetchBuffer_Enable);
  69              //FLASHå»¶è¿Ÿ2ä¸ªå‘¨æœŸ
  70              FLASH_SetLatency(FLASH_Latency_2);  
  71            //é…ç½®AHB(HCLK)æ—¶é’Ÿ=SYSCLK
  72              RCC_HCLKConfig(RCC_SYSCLK_Div1);    
  73             //é…ç½®APB2(PCLK2)é’Ÿ=AHBæ—¶é’Ÿ
  74              RCC_PCLK2Config(RCC_HCLK_Div1); 
  75              //é…ç½®APB1(PCLK1)é’Ÿ=AHB 1/2æ—¶é’Ÿ
  76              RCC_PCLK1Config(RCC_HCLK_Div2);
  77               //é…ç½®PLLæ—¶é’Ÿ == å¤–éƒ¨é«˜é€Ÿæ™¶ä½“æ—¶é’Ÿ*9 PLLCLK = 8MHz * 9 = 72 MHz 
  78              RCC_PLLConfig(RCC_PLLSource_HSE_Div1, RCC_PLLMul_9);
  79              //ä½¿èƒ½PLLæ—¶é’Ÿ
  80              RCC_PLLCmd(ENABLE);
  81             //ç­‰å¾…PLLæ—¶é’Ÿå°±ç»ª
  82              while(RCC_GetFlagStatus(RCC_FLAG_PLLRDY) == RESET)
  83              {
  84              }
  85            //é…ç½®ç³»ç»Ÿæ—¶é’Ÿ = PLLæ—¶é’Ÿ
  86              RCC_SYSCLKConfig(RCC_SYSCLKSource_PLLCLK);
  87             //æ£€æŸ¥PLLæ—¶é’Ÿæ˜¯å¦ä½œä¸ºç³»ç»Ÿæ—¶é’Ÿ
  88              while(RCC_GetSYSCLKSource() != 0x08)
  89              {
  90              }
  91            }
  92          }
  93          
  94          //NVICåˆå§‹åŒ–
  95          void NVIC_Configuration(void)
  96          {
  97           NVIC_InitTypeDef NVIC_InitStructure;
  98          #ifdef  VECT_TAB_RAM  
                NVIC_SetVectorTable(NVIC_VectTab_RAM, 0x0); 
              #else  /* VECT_TAB_FLASH */ 
 101            NVIC_SetVectorTable(NVIC_VectTab_FLASH, 0x0);   
 102          #endif
 103            NVIC_InitStructure.NVIC_IRQChannel = TIM2_IRQChannel;
 104            NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0;
 105            NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;
 106            NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
 107            NVIC_Init(&NVIC_InitStructure);
 108          }
 109          #ifdef  DEBUG
              
              //**å»¶æ—¶å‡½æ•°*
              void NOP()
              { vu16 i;
                for(i=0; i<100; i++); 
              }
C51 COMPILER V9.59.0.0   NEW                                                               05/25/2024 19:24:56 PAGE 3   

              
              //å»¶æ—¶å‡½æ•°
              void delay(vu32 nCount)
              {
                for(; nCount != 0; nCount--);
              }
              
              void assert_failed(u8* file, u32 line)
              { 
                while (1)
                {
                }
              }
              #endif
 130          
 131          //å»¶æ—¶å­ç¨‹åº 
 132          void  delay0(BYTE x)
 133          { BYTE j;
 134              while((x--)!=0)  //CPUæ‰§è¡Œx*12æ¬¡
 135              { for(j=0;j<125;j++)
 136                   {;}
 137              }
 138          }
 139          
 140          void result2char(void)    //å°†è®¡ç®—ç»“æœè½¬åŒ–ä¸ºå¯æ˜¾ç¤ºçš„å­—ç¬¦ä¸²
 141          {
 142            dis2[5]=operand[0]%10+48;
 143             dis2[4]=operand[0]/10%10+48;
 144             dis2[3]=operand[0]/100%10+48;
 145             dis2[2]=operand[0]/1000%10+48;
 146             dis2[1]=operand[0]/10000%10+48;
 147             dis2[0]=operand[0]/100000%10+48;
 148             if(dis2[0]==48)
 149             {  dis2[0]=32;
 150              if(dis2[1]==48)  
 151              { dis2[1]=32;
 152                if(dis2[2]==48)  
 153                { dis2[2]=32;
 154                  if(dis2[3]==48)  
 155                  { dis2[3]=32;
 156                    if(dis2[4]==48)  
 157                    { dis2[4]=32; }
 158                  }
 159                }
 160              }
 161            }
 162          }
 163          
 164          void calculate(void)      //åˆ¤æ–­é”®ç›˜é”®æ˜¯å¦æŒ‰ä¸‹
 165          {
 166            i = 0;
 167             str++;
 168               while(*str != '\0')
 169               {
 170                  temp_p = dest;
 171              m=0;
 172                  while(*str >= 48 && *str <= 57)           /*åˆ¤æ–­æ˜¯å¦æ˜¯æ•°æ®*/
 173                  {
 174                      *temp_p = *str;
 175                      str ++;
 176                      temp_p ++;
 177                m++;                
C51 COMPILER V9.59.0.0   NEW                                                               05/25/2024 19:24:56 PAGE 4   

 178                  }                               /*é‡åˆ°ç¬¦å·é€€å‡º*/
 179                  if(*str != '(' && *(temp_p - 1) != '\0')      /*åˆ¤æ–­ç¬¦å·æ˜¯å¦ä¸º'('*/
 180                  {
 181                      *temp_p = '\0';
 182                      num = atoi(dest);               /*å°†å­—ç¬¦ä¸²è½¬ä¸ºæ•°å­—*/
 183                      insert_operand(operand, &top_num,num);      /*å°†æ•°æ®å‹å…¥æ•°æ®æ ˆ*/
 184                  }
 185                   while(1)        
 186                   {
 187                       i = compare(oper,&top_oper,*str);      /*åˆ¤æ–­æ“ä½œç¬¦ä¼˜å…ˆçº§*/
 188                      if(i == 0)
 189                      {
 190                          insert_oper(oper,&top_oper,*str);   /*å‹å…¥æ“ä½œç¬¦*/
 191                          break;
 192                      }
 193                      else if(i == 1)                         /*åˆ¤æ–­æ‹¬å·å†…çš„è¡¨è¾¾å¼æ˜¯å¦ç»“æŸ*/
 194                      {
 195                          str++;
 196                      }
 197                      else if(i == -1)                        /*è¿›è¡Œæ•°æ®å¤„ç†*/
 198                      {
 199                          deal_date(operand,oper,&top_num,&top_oper);
 200                      }
 201                   }
 202                  str ++;
 203            }
 204          }
 205                                                                    
 206          //é”®æ‰«æå­ç¨‹åº (4*3 çš„çŸ©é˜µ) P0.4 P0.5 P0.6 P0.7ä¸ºè¡Œ 
 207          void keyscan(void)
 208           {  temp = 0;
 209            GPIO_InitStructure.GPIO_Pin = GPIO_Pin_0 |  GPIO_Pin_1 |  GPIO_Pin_2 |  GPIO_Pin_3 ; // é€‰æ‹©æ‰€æœ‰è„š
 210              GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;  //é…ç½®æˆæ¨æŒ½å¼è¾“å‡º
 211              GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz; //è¾“å‡ºæ¨¡å¼ä¸‹ I/Oè¾“å‡ºé€Ÿåº¦ 50M HZ
 212              GPIO_Init(GPIOB, &GPIO_InitStructure);  //åˆPBå£å§‹åŒ–
 213            GPIO_InitStructure.GPIO_Pin = GPIO_Pin_4 |  GPIO_Pin_5 |  GPIO_Pin_6 |  GPIO_Pin_7 ; // é€‰æ‹©æ‰€æœ‰è„š
 214              GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;  //é…ç½®æˆæ¨æŒ½å¼è¾“å‡º
 215              GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz; //è¾“å‡ºæ¨¡å¼ä¸‹ I/Oè¾“å‡ºé€Ÿåº¦ 50M HZ
 216              GPIO_Init(GPIOB, &GPIO_InitStructure);  //åˆPBå£å§‹åŒ–
 217            GPIO_Write(GPIOB,0X00F0); //åˆå§‹åŒ–ç«¯å£
 218              delay0(1);         //å»¶æ—¶
 219              temp=(GPIO_ReadInputData(GPIOB))&0xF0;   //é«˜8ä½çš„å±è”½ä½å››ä½
 220              temp=~((temp>>4)|0x00F0); //å°†é«˜å››ä½ç§»åˆ°åœ°ä½å¤„å¤„ç† 
 221              if(temp==1)   // p0.4 è¢«æ‹‰ä½
 222              {    key=1;   //ç¬¬ä¸€ä¸ªæŒ‰é”®å€¼
 223              flag_buf=1;
 224              }else if(temp==2)   // p0.5 è¢«æ‹‰ä½
 225              {    key=2;  //ç¬¬2ä¸ªæŒ‰é”®å€¼
 226              flag_buf=1;
 227              }else if(temp==4)   // p0.6 è¢«æ‹‰ä½
 228              {    key=3;   //ç¬¬3ä¸ªæŒ‰é”®å€¼
 229              flag_buf=1;
 230              }else if(temp==8)   // p0.7 è¢«æ‹‰ä½
 231              {     key=4;     //ç¬¬4ä¸ªæŒ‰é”®å€¼
 232               flag_buf=1;
 233              }else key=16;
 234          
 235              GPIO_InitStructure.GPIO_Pin = GPIO_Pin_0 |  GPIO_Pin_1 |  GPIO_Pin_2 |  GPIO_Pin_3 ; // é€‰æ‹©æ‰€æœ‰è„
             -š
 236              GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;  //é…ç½®æˆæ¨æŒ½å¼è¾“å‡º
 237              GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz; //è¾“å‡ºæ¨¡å¼ä¸‹ I/Oè¾“å‡ºé€Ÿåº¦ 50M HZ
 238              GPIO_Init(GPIOB, &GPIO_InitStructure);  //åˆPBå£å§‹åŒ–
C51 COMPILER V9.59.0.0   NEW                                                               05/25/2024 19:24:56 PAGE 5   

 239            GPIO_InitStructure.GPIO_Pin = GPIO_Pin_4 |  GPIO_Pin_5 |  GPIO_Pin_6 |  GPIO_Pin_7 ; // é€‰æ‹©æ‰€æœ‰è„š
 240              GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;  //é…ç½®æˆæ¨æŒ½å¼è¾“å‡º
 241              GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz; //è¾“å‡ºæ¨¡å¼ä¸‹ I/Oè¾“å‡ºé€Ÿåº¦ 50M HZ
 242              GPIO_Init(GPIOB, &GPIO_InitStructure);  //åˆPBå£å§‹åŒ–
 243            GPIO_Write(GPIOB,0X000F);
 244              delay0(1);       //å»¶æ—¶
 245              temp=(GPIO_ReadInputData(GPIOB))&0x0F;
 246              temp=~(temp|0xF0);
 247            if(temp==1)      //p0.0 è¢«æ‹‰ä½
 248              {    key=key+0;
 249              flag_buf=1;
 250              }else if(temp==2)      //p0.1 è¢«æ‹‰ä½
 251              {    key=key+4;
 252              flag_buf=1;
 253              }else if(temp==4)   //p0.2 è¢«æ‹‰ä½
 254              {    key=key+8;
 255              flag_buf=1;
 256              }else if(temp==8) //p0.3 è¢«æ‹‰ä½
 257              {   key=key+12;
 258              flag_buf=1;
 259              }else   key=16;  
 260          
 261            if(key==11) {fuhao=40; flag_fuhao=1 ;flag_fuhao2=1;flag_buf=0;}
 262            if(key==12) {fuhao=41; flag_fuhao=1 ;flag_fuhao2=1;flag_buf=0;}     
 263              dis_buf = key;      //é”®å€¼å…¥æ˜¾ç¤ºç¼“å­˜
 264              dis_buf = dis_buf & 0x0f;
 265          }
 266          
 267          //ç‹¬ç«‹é”®ç›˜æ‰«æå­ç¨‹åº (2*4 çš„çŸ©é˜µ) P0.4 P0.5 P0.6 P0.7ä¸ºè¡Œ 
 268          void  duli_keyscan(void)
 269          {
 270            temp = 0;
 271            GPIO_InitStructure.GPIO_Pin = GPIO_Pin_All; //æ‰€æœ‰GPIOä¸ºåŒä¸€ç±»å‹ç«¯å£
 272            GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;   //æ¨æŒ½è¾“å‡º
 273            GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;  //è¾“å‡ºçš„æœ€å¤§é¢‘ç‡ä¸º50HZ
 274            GPIO_Init(GPIOA, &GPIO_InitStructure);   //åˆå§‹åŒ–GPIOAç«¯å£
 275          
 276            GPIO_InitStructure.GPIO_Pin = GPIO_Pin_0 |  GPIO_Pin_1 | GPIO_Pin_2 |  GPIO_Pin_3 | GPIO_Pin_4 |  GPIO_Pi
             -n_5 |  GPIO_Pin_6 |  GPIO_Pin_7 ; // é€‰æ‹©æ‰€æœ‰è„š
 277              GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;  //é…ç½®æˆæ¨æŒ½å¼è¾“å‡º
 278              GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz; //è¾“å‡ºæ¨¡å¼ä¸‹ I/Oè¾“å‡ºé€Ÿåº¦ 50M HZ
 279              GPIO_Init(GPIOA, &GPIO_InitStructure);  //åˆPBå£å§‹åŒ–
 280          
 281            GPIO_Write(GPIOA,0X00FF); //åˆå§‹åŒ–ç«¯å£
 282              delay0(1);         //å»¶æ—¶
 283              temp=(GPIO_ReadInputData(GPIOA)) &0x00FF;  //é«˜8ä½çš„å±è”½ä½å››ä½
 284              temp=~temp; //å°†é«˜å››ä½ç§»åˆ°åœ°ä½å¤„å¤„ç† 
 285              if(temp==16)    // p0.4 è¢«æ‹‰ä½
 286              {   fuhao=43;   //ç¬¬ä¸€ä¸ªæŒ‰é”®å€¼
 287              flag_fuhao=1;
 288              flag_fuhao2=1;
 289              }
 290            else if(temp==32)   // p0.5 è¢«æ‹‰ä½
 291              {    fuhao=45;   //ç¬¬2ä¸ªæŒ‰é”®å€¼
 292              flag_fuhao=2;
 293              flag_fuhao2=1;
 294              }
 295            else if(temp==64)   // p0.6 è¢«æ‹‰ä½
 296              {    fuhao=42;    //ç¬¬3ä¸ªæŒ‰é”®å€¼
 297              flag_fuhao=3;
 298              flag_fuhao2=1;
 299              }
C51 COMPILER V9.59.0.0   NEW                                                               05/25/2024 19:24:56 PAGE 6   

 300            else if(temp==128)   // p0.7 è¢«æ‹‰ä½
 301              {    fuhao=47;     //ç¬¬4ä¸ªæŒ‰é”®å€¼
 302              flag_fuhao=4;
 303              flag_fuhao2=1;
 304              }
 305            else if(temp==4)   // p0.6 è¢«æ‹‰ä½
 306              {    fuhao=40;    //ç¬¬3ä¸ªæŒ‰é”®å€¼
 307              flag_fuhao=3;
 308              flag_fuhao2=1;
 309              }
 310            else if(temp==8)   // p0.7 è¢«æ‹‰ä½
 311              {    fuhao=41;     //ç¬¬4ä¸ªæŒ‰é”®å€¼
 312              flag_fuhao=4;
 313              flag_fuhao2=1;
 314              }
 315            else if(temp==1)
 316              {    //fuhao=61;
 317              flag=1;
 318            }
 319            else if(temp!=0)
 320            {  flag=2;} 
 321          }
 322          
 323          //å‡½æ•°ï¼šåˆ¤æ–­é”®æ˜¯å¦æŒ‰ä¸‹ 
 324           void  keydown(void)
 325           {   int retval;
 326              //P1=0xF0; //å°†é«˜4ä½å…¨éƒ¨ç½®1 ä½å››ä½å…¨éƒ¨ç½®0
 327            GPIO_InitStructure.GPIO_Pin = GPIO_Pin_0 |  GPIO_Pin_1 |  GPIO_Pin_2 |  GPIO_Pin_3 ; // é€‰æ‹©æ‰€æœ‰è„š
 328              GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;  //é…ç½®æˆæ¨æŒ½å¼è¾“å‡º
 329              GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz; //è¾“å‡ºæ¨¡å¼ä¸‹ I/Oè¾“å‡ºé€Ÿåº¦ 50M HZ
 330              GPIO_Init(GPIOB, &GPIO_InitStructure);  //åˆPBå£å§‹åŒ–
 331          
 332            GPIO_InitStructure.GPIO_Pin = GPIO_Pin_4 |  GPIO_Pin_5 |  GPIO_Pin_6 |  GPIO_Pin_7 ; // é€‰æ‹©æ‰€æœ‰è„š
 333              GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;  //é…ç½®æˆæ‚¬æµ®è¾“å…¥
 334              GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz; //è¾“å‡ºæ¨¡å¼ä¸‹ I/Oè¾“å‡ºé€Ÿåº¦ 50M HZ
 335              GPIO_Init(GPIOB, &GPIO_InitStructure);  //åˆPBå£å§‹åŒ–
 336          
 337            GPIO_Write(GPIOB,0X00F0);
 338            //P1!=0xF0
 339            retval =  GPIO_ReadInputData(GPIOB); //è¯»PBå£çŠ¶æ€
 340            if(retval !=0xF0)  //åˆ¤æ–­æŒ‰é”®æ˜¯å¦æŒ‰ä¸‹ å¦‚æœæŒ‰é’®æŒ‰ä¸‹ ä¼šæ‹‰ä½P1å…¶ä¸­çš„ä¸€ä¸ªç«¯å£
 341            {
 342              keyscan();  //è°ƒç”¨æŒ‰é”®æ‰«æç¨‹åº
 343              }
 344          }
 345            
 346          
 347          /*æ•°æ®å‹å…¥æ•°æ®æ ˆ*/
 348          int insert_operand(int *operand , int * top_num ,BYTE num)           /*æ•°æ®å‹å…¥æ•°æ®æ ˆ*/
 349          {
 350              (*top_num) ++;
 351              operand[*top_num] = num;                    /*ä¿å­˜æ•°æ®*/   
 352              return 0;                           /*æ­£å¸¸é€€å‡º*/
 353          }
 354           
 355           /*æ“ä½œç¬¦å‹å…¥ç¬¦å·æ ˆ*/
 356          int insert_oper (BYTE * oper , int *top_oper , char ch)             /*æ“ä½œç¬¦å‹å…¥ç¬¦å·æ ˆ*/
 357          {
 358              (*top_oper)++;
 359              oper[*top_oper] = ch;                       /*ä¿å­˜æ“ä½œç¬¦*/
 360              return 0;                           /*æ­£å¸¸é€€å‡º*/
 361          }
C51 COMPILER V9.59.0.0   NEW                                                               05/25/2024 19:24:56 PAGE 7   

 362          
 363          /*æ¯”è¾ƒæ“ä½œæœä¼˜å…ˆçº§*/ 
 364          int compare(BYTE *oper , int *top_oper , BYTE ch)                   /*æ¯”è¾ƒæ“ä½œæœä¼˜å…ˆçº§*/
 365          {      
 366              if((oper[*top_oper] == '-' || oper[*top_oper] == '+')           /*åˆ¤æ–­å½“å‰ä¼˜å…ˆçº§æ˜¯å¦æ¯”æ ˆé¡¶
             -æ“ä½œç¬¦ä¼˜å…ˆçº§é«˜*/
 367                      && (ch == '*' || ch == '/'))
 368              {
 369                  return 0;                      /*æ“ä½œç¬¦å‹å…¥æ ˆ*/ 
 370              } 
 371              else if(*top_oper == -1 || ch == '(' 
 372                      || (oper[*top_oper] == '(' && ch != ')'))       /*åˆ¤æ–­æ“ä½œç¬¦æ ˆæ˜¯å¦ä¸ºç©ºï¼›æ ˆé¡¶æ“ä½
             -œ ç¬¦æ˜¯å¦ä¸º'('*/
 373              {
 374                  return 0;                       /*æ“ä½œç¬¦å‹å…¥æ ˆ*/
 375              } 
 376              else if (oper[*top_oper] =='(' && ch == ')' )       /*åˆ¤æ–­æ‹¬å·å†…çš„è¡¨è¾¾å¼æ˜¯å¦è®¡ç®—å®Œæ¯•*/
 377              {
 378                  (*top_oper)--;
 379                  return 1;                       /*å¯¹ï¼ˆï¼‰è¿›è¡Œå¤„ç†*/
 380              } 
 381              else
 382              {
 383                  return -1;                                          /*è¿›è¡Œæ“ä½œç¬¦çš„è¿ç®—*/
 384              }
 385          }
 386          
 387          /*è¿›è¡Œæ•°æ®è¿ç®—*/ 
 388          int deal_date(int *operand ,BYTE *oper ,int *top_num, int *top_oper)    /*è¿›è¡Œæ•°æ®è¿ç®—*/
 389          {
 390              int num_1 = operand[*top_num];              /*å–å‡ºæ•°æ®æ ˆä¸­ä¸¤ä¸ªæ•°æ®*/
 391              int num_2 = operand[*top_num - 1];
 392              int value = 0;
 393              if(oper[*top_oper] == '+')                  /*åŠ æ³•æ“ä½œ*/
 394              {
 395                  value = num_1 + num_2;
 396              } 
 397              else if(oper[*top_oper] == '-')             /*å‡æ³•æ“ä½œ*/
 398              {
 399                  value = num_2 - num_1;
 400              } 
 401              else if(oper[*top_oper] == '*')             /*ä¹˜æ³•æ“ä½œ*/
 402              {
 403                  value = num_2 * num_1;
 404              }
 405              else if(oper[*top_oper] == '/')             /*é™¤æ³•æ“ä½œ*/
 406              {
 407                  value = num_2 / num_1;
 408              }
 409              (*top_num) --;                              /*å°†æ•°æ®æ ˆé¡¶ä¸‹ç§»ä¸€ä½*/
 410              operand[*top_num] = value;                  /*å°†å¾—åˆ°çš„å€¼å‹å…¥æ•°æ®æ ˆ*/
 411              (*top_oper) --;                             /*å°†æ“ä½œç¬¦æ ˆé¡¶ä¸‹ç§»ä¸€ä½*/ 
 412          }
 413          
 414          /***********æµ‹è¯•LCDç¹å¿™çŠ¶æ€**********************/  
 415          BOOL lcd_bz()
 416          {                         // æµ‹è¯•LCDå¿™ç¢ŒçŠ¶æ€
 417            BOOL result;
 418            LCD_RS(0);  //0;
 419            LCD_RW(1);  //1;
 420            LCD_EN(1);  //1;
 421            NOP();
C51 COMPILER V9.59.0.0   NEW                                                               05/25/2024 19:24:56 PAGE 8   

 422            NOP();
 423            result = (GPIO_ReadInputData(GPIOB) & 0x8000)>>8;
 424            LCD_EN(0); // 0;
 425            return result; 
 426          }
 427          /*********å†™å‘½ä»¤****************/  
 428          lcd_wcmd(long cmd)
 429          {                          // å†™å…¥æŒ‡ä»¤æ•°æ®åˆ°LCD
 430          // while(lcd_bz());
 431            LCD_RS(0); // 0;
 432            LCD_RW(0); // 0;
 433            LCD_EN(0); // 0;
 434            NOP();
 435            NOP(); 
 436            GPIOB->BSRR = cmd<<8 & 0xf000;  //å°†æ•°æ®é€åˆ°P0å£ 
 437              GPIOB->BRR = ((~cmd)<<8) & 0xf000;
 438            NOP();
 439            NOP();  
 440            LCD_EN(1); // 1;
 441            NOP();  
 442            NOP();  
 443            LCD_EN(0); // 0; 
 444          }
 445          
 446          lcd_wcmd_4bit(long cmd)
 447          {                          // å†™å…¥æŒ‡ä»¤æ•°æ®åˆ°LCD
 448            while(lcd_bz());
 449            LCD_RS(0); // 0;
 450            LCD_RW(0); // 0;
 451            LCD_EN(0); // 0;
 452            NOP();
 453            NOP();   NOP();
 454            NOP();
 455            GPIOB->BSRR = cmd<<8 & 0xf000;  //å°†æ•°æ®é€åˆ°P0å£ 
 456              GPIOB->BRR = ((~cmd)<<8) & 0xf000;
 457            NOP();   NOP();
 458            NOP();
 459            NOP();  
 460            LCD_EN(1); // 1;
 461            NOP();  
 462            NOP();  NOP();
 463            NOP();
 464            LCD_EN(0); // 0; 
 465            LCD_RS(0); //= 1;
 466            LCD_RW(0); //= 0;
 467            LCD_EN(0); //= 0;
 468            NOP();
 469            NOP();   NOP();
 470            NOP();
 471            GPIOB->BSRR = cmd<<12 & 0xf000;  //å°†æ•°æ®é€åˆ°P0å£ 
 472              GPIOB->BRR = ((~cmd)<<12) & 0xf000;
 473            NOP();
 474            NOP();   NOP();
 475            NOP();
 476            LCD_EN(1); // 1;
 477            NOP();  
 478            NOP();  NOP();
 479            NOP();
 480            LCD_EN(0); // 0; 
 481          }
 482            
 483          lcd_pos(long pos)
C51 COMPILER V9.59.0.0   NEW                                                               05/25/2024 19:24:56 PAGE 9   

 484          {                          //è®¾å®šæ˜¾ç¤ºä½ç½®
 485            lcd_wcmd_4bit(pos | 0x0080);
 486          }                  
 487          
 488          lcd_init()        //LCDåˆå§‹åŒ–è®¾å®š
 489          {                       
 490            lcd_wcmd(0x38);          //16*2æ˜¾ç¤ºï¼Œ5*7ç‚¹é˜µï¼Œ8ä½æ•°æ®
 491            delay(20000);
 492            lcd_wcmd(0x38);          //16*2æ˜¾ç¤ºï¼Œ5*7ç‚¹é˜µï¼Œ8ä½æ•°æ® /
 493            delay(20000);
 494            lcd_wcmd(0x28);          //16*2æ˜¾ç¤ºï¼Œ5*7ç‚¹é˜µï¼Œ8ä½æ•°æ®
 495            delay(20000);
 496            lcd_wcmd_4bit(0x28);          //16*2æ˜¾ç¤ºï¼Œ5*7ç‚¹é˜µï¼Œ8ä½æ•°æ®
 497            delay(20000);
 498            lcd_wcmd_4bit(0x0c);          //æ˜¾ç¤ºå¼€ï¼Œå…³å…‰æ ‡
 499            delay(20000);
 500            lcd_wcmd_4bit(0x02);          //ç§»åŠ¨å…‰æ ‡
 501            delay(20000);
 502            lcd_wcmd_4bit(0x01);          //æ¸…é™¤LCDçš„æ˜¾ç¤ºå†…å®¹
 503            delay(20000);
 504          }
 505          
 506          /*****************å†™æ•°æ®***********************/ 
 507          lcd_wdat( long dat) 
 508          {                          //å†™å…¥å­—ç¬¦æ˜¾ç¤ºæ•°æ®åˆ°LCD
 509            while(lcd_bz());
 510            LCD_RS(1); //= 1;
 511            LCD_RW(0); //= 0;
 512            LCD_EN(0); //= 0;
 513            
 514            GPIOB->BSRR = dat<<8 & 0xf000;    P0 = dat
 515              GPIOB->BRR = ((~dat)<<8) & 0xf000;
 516            NOP();
 517            NOP();
 518            NOP();
 519            NOP();
 520            LCD_EN(1);// = 1;
 521            NOP();
 522            NOP();
 523            NOP();
 524            NOP();
 525            LCD_EN(0);// = 0; 
 526          
 527            LCD_RS(1); //= 1;
 528            LCD_RW(0); //= 0;
 529            LCD_EN(0); //= 0;
 530            NOP();
 531            NOP();
 532            NOP();
 533            NOP();
 534            GPIOB->BSRR = dat<<12 & 0xf000;    P0 = dat
 535              GPIOB->BRR = ((~dat)<<12) & 0xf000;
 536            NOP();
 537            NOP();
 538            NOP();
 539            NOP();
 540            LCD_EN(1);// = 1;
 541            NOP();
 542            NOP();
 543            NOP();
 544            NOP();
 545            LCD_EN(0);// = 0; 
C51 COMPILER V9.59.0.0   NEW                                                               05/25/2024 19:24:56 PAGE 10  

 546          }
 547          
 548          void LCD(void)
 549          {
 550            lcd_wcmd_4bit(0x06);            //å‘å³ç§»åŠ¨å…‰æ ‡
 551                lcd_pos(0);                //è®¾ç½®æ˜¾ç¤ºä½ç½®ä¸ºç¬¬ä¸€è¡Œçš„ç¬¬1ä¸ªå­—ç¬¦
 552                i = 0;
 553               while(dis1[ i ] != '\0')
 554               {                           //æ˜¾ç¤ºå­—ç¬¦
 555                 lcd_wdat(dis1[ i ]);
 556                 i++;
 557                 delay(20000);                //æ§åˆ¶ä¸¤å­—ä¹‹é—´æ˜¾ç¤ºé€Ÿåº¦
 558               }
 559                lcd_pos(0x40);             //è®¾ç½®æ˜¾ç¤ºä½ç½®ä¸ºç¬¬äºŒè¡Œç¬¬1ä¸ªå­—ç¬¦
 560                i = 0;
 561               while(dis2[ i ] != '\0')
 562               {
 563                 lcd_wdat(dis2[ i ]);      //æ˜¾ç¤ºå­—ç¬¦
 564                 i++;
 565                 delay(20000);                //æ§åˆ¶ä¸¤å­—ä¹‹é—´æ˜¾ç¤ºé€Ÿåº¦
 566               }
 567                delay(800000);                //æ§åˆ¶åœç•™æ—¶é—´ 
 568          } 
 569            
 570          main()
 571          {
 572            j=1;
 573            #ifdef DEBUG
                //debug(); //åœ¨çº¿è°ƒè¯•ä½¿ç”¨
                #endif  
 576            RCC_Configuration();      //ç³»ç»Ÿæ—¶é’Ÿé…ç½®å‡½æ•° 
 577            NVIC_Configuration();     //NVICé…ç½®å‡½æ•° 
 578            RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA | RCC_APB2Periph_GPIOB | RCC_APB1Periph_TIM2 | RCC_APB2Periph
             -_AFIO, ENABLE);//å¯åŠ¨GPIOæ¨¡å—æ—¶é’Ÿ 
 579            GPIO_PinRemapConfig(GPIO_Remap_SWJ_Disable,ENABLE);  //æŠŠè°ƒè¯•è®¾ç½®æ™®é€šIOå£ 
 580            GPIO_InitStructure.GPIO_Pin = GPIO_Pin_All; //æ‰€æœ‰GPIOä¸ºåŒä¸€ç±»å‹ç«¯å£
 581            GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;   //æ¨æŒ½è¾“å‡º
 582            GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;  //è¾“å‡ºçš„æœ€å¤§é¢‘ç‡ä¸º50HZ
 583            GPIO_Init(GPIOA, &GPIO_InitStructure);   //åˆå§‹åŒ–GPIOAç«¯å£
 584            GPIO_Init(GPIOB, &GPIO_InitStructure);   //åˆå§‹åŒ–GPIOBç«¯å£
 585              GPIO_InitStructure.GPIO_Pin = GPIO_Pin_8 | GPIO_Pin_9 | GPIO_Pin_10 | GPIO_Pin_11 |GPIO_Pin_12 | GPIO_
             -Pin_13 | GPIO_Pin_14 | GPIO_Pin_15; //æ‰€æœ‰GPIOä¸ºåŒä¸€ç±»å‹ç«¯å£
 586            GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_OD;   //å¼€æ¼è¾“å‡º
 587            GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;  //è¾“å‡ºçš„æœ€å¤§é¢‘ç‡ä¸º50HZ
 588            GPIO_Init(GPIOB, &GPIO_InitStructure);   //åˆå§‹åŒ–GPIOBç«¯å£
 589            GPIO_Write(GPIOA,0xffff);  //å°†GPIOA 16ä¸ªç«¯å£å…¨éƒ¨ç½®ä¸ºé«˜ç”µå¹³
 590            GPIO_Write(GPIOB,0xffff);  //å°†GPIOB 16ä¸ªç«¯å£å…¨éƒ¨ç½®ä¸ºé«˜ç”µ
 591            lcd_init();               // åˆå§‹åŒ–LCD
 592              delay(10);  
 593          
 594             while(1)              
 595             {   
 596              //è¾“å…¥è¡¨è¾¾å¼ï¼šçŸ©é˜µé”®ç›˜è¾“å…¥æ•°å­—ï¼Œç‹¬ç«‹é”®ç›˜è¾“å…¥ç¬¦å· 
 597              while(flag_buf==0 && flag_fuhao2==0 && flag ==0)
 598              {
 599                keydown();   //çŸ©é˜µæŒ‰é”®æ£€æµ‹
 600                delay(20);
 601                duli_keyscan();  //ç‹¬ç«‹æŒ‰é”®æ£€æµ‹
 602                delay(20);
 603                lcd_wcmd_4bit(0x01);//æ¸…é™¤LCDçš„å†…å®¹
 604                delay(2000);
 605                LCD();   //å®æ—¶æ˜¾ç¤ºæŒ‰é”®çš„è¡¨è¾¾å¼
C51 COMPILER V9.59.0.0   NEW                                                               05/25/2024 19:24:56 PAGE 11  

 606              }
 607             //å¦‚æœæœ‰è¾“å…¥æ•°å­—ï¼Œå°†å…¶æ˜¾ç¤ºåœ¨LCDå±ä¸Š
 608              if(flag_buf!=0)
 609              {
 610               dis1[j]=dis_buf+48;
 611              }
 612              //å¦‚æœæœ‰è¾“å…¥ç¬¦å·ï¼Œå°†å…¶æ˜¾ç¤ºåœ¨LCDå±ä¸Š
 613              else if(flag_fuhao2!=0)
 614              {
 615               dis1[j]=fuhao;
 616              }
 617              //æ¸…é™¤flagå€¼
 618              j++;
 619              flag_buf=0;
 620              flag_fuhao=0;
 621              flag_fuhao2=0;            
 622              if(flag==1)    
 623              {              
 624               calculate(); //è®¡ç®—è¡¨è¾¾å¼çš„å€¼ 
 625               result2char();//å°†è®¡ç®—ç»“æœè½¬åŒ–ä¸ºå­—ç¬¦ä¸²
 626               dis2[0]=61;  //è¾“å…¥â€œ=â€
 627               flag_fuhao=0;    //æ¸…ç©ºflag
 628               flag=0;
 629              }
 630              //å¦‚æœæœ‰æ¸…å±æŒ‡ä»¤ï¼Œåˆ™æ¸…é™¤å±å¹•ï¼Œé‡æ–°å¼€å§‹è¾“å…¥
 631              if(flag==2)   
 632              {
 633                flag=0;
 634              j=1;
 635              for(m=0;m<16;m++)
 636              {
 637                 dis1[m]=32;
 638                }
 639              for(m=0;m<16;m++)
 640              {
 641                 dis2[m]=32;
 642                }
 643                delay(2000);
 644                LCD();
 645                } 
 646             }
 647          }

C51 COMPILATION COMPLETE.  0 WARNING(S),  1 ERROR(S)
